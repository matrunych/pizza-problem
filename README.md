В цій практичній роботі вам необхідно написати пошуковий алгоритм (на основі пошукової парадигми), який би покращував початкове рішення для задачі Pizza. Ваш алгоритм повинен працювати на принципах локального пошуку або із застосуванням метаевристик. Ви самі обираєте який підхід застосувати.

Щоби спростити вам роботу та дозволити сконцентруватися саме на розробці пошукового алгоритму, вам наданий основний кістяк проекту, який складається з наступних модулів та класів. 

* клас **Problem** (файл `problem.py`) — представляє в пам’яті екземпляр задачі. Важливими методами цього класу є:

    * `is_valid_slice` — перевіряє, чи шматок заданий координатами лівого верхнього кута та шириною і довжиною є валідним (див. опис валідності у файлі з описом задачі);
    * `slices_formats` — повертає список всіх можливих співвідношень сторін валідних шматків піци;
    * `valid` — перевіряє чи точка із заданими координатами лежить в площині піци.

* клас **Solution** (файл `solution.py`) — представляє конкретний розв’язок задачі Pizza. Всередині розв’язок представляється полем всієї піци (масив `slices`), де кожна комірка (частинка) піци або є вільною, тобто ще не належить жодному шматку, (масив `free`) або належить якомусь шматку піци (при цьому шматок визначається своїми значеннями довжини та ширини, які записані в ліву верхню комірку/частинку — початок шматка). Клас має методи:
    * `create_new_slice` — створює новий шматок, який заданий лівим верхнім кутом та довжиною і шириною; 
    * `delete_slice` — видаляє заданий шматок (тобто комірки відповідного шматка перестають йому належати); 
    * `duplicate` — створює копію поточного розв’язку у вигляді нового об’єкту класу `Solution`; 
    * `get_all_slices` — повертає список всіх шматків піци; 
    * `get_hash` — обраховує деяке хеш-значення для поточного рішення, може бути корисним для розрізнювання окремих розв’язків під час роботи пошукової процедури; 
    * `get_overlaps` — повертає список шматків, які перекривають заданий блок піци;
    * `is_free_space` — перевіряє, чи заданий блок піци є вільним від шматків; 
    * `is_OK` — перевіряє, чи поточне рішення є валідним (див. опис валідності у файлі з описом задачі); 
    * `pick_random_slice` — обирає випадковий шматок піци; 
    * `print_free` — виводить в консоль карту піци із позначеними вільними комірками; 
    * `print_solution` — виводить в консоль карту піци із розміченими різними шматками; 
    * `score` — обраховує кількість балів для заданого рішення (див. відповідний розділ у файлі з описом задачі).

* клас **FileReader** та його сестринські класи (файл `reader.py`) — зчитує екземпляр задачі у об’єкт класу `Problem`.

* клас **FileWriter** та його сестринські класи (файл `writer.py`) — записує рішення задачі з об’єкту класу `Solution`.

* класи **InitSolver**, **InitSolverSilly** (файл `init_solver.py`) — класи, які генерують початкове рішення для задачі з `Problem` на основі простого жадібного підходу і записують результат в об’єкт класу `Solution`.

* клас **Solver** (файл `task_09.py`) — генерує розв’язок задачі. Ваше завдання полягає в реалізації методів цього класу, а саме:
    * `description` — допоміжний метод, який повинен повертати опис алгоритму розв’язання;
    * `initial_solution` — генерує початкове рішення. Ви можете лишити цей метод як він є; наразі генерується рішення за допомогою одного з класів групи `InitSolver` або переписати його, щоби отримувати покращене початкове рішення. 
    * `search` — основний метод, який ви повинні реалізувати; 
        * метод приймає на вхід поточне рішення (об’єкт класу `Solution`) та намагається його покращити, повертаючи оновлений об’єкт `Solution`; 
        * також передається часове обмеження (кількість секунд), за яке метод не повинен перейти під час роботи; 
        * ви повинні зберігати значення розв’язків (кількість балів) для проміжних знайдених рішень (під час роботи локального пошуку або метаевристики) у поле trace класу `Solver`.

- файл `main.py` в якому присутній приклад сценарію розв’язання задачі:
    * екземпляр `Problem` зчитується з файлу за допомогою `Reader`;
    * генерується початкове рішення `Solution` за допомогою `Solver.initial_solution`;
    * на основі згенерованого початкового рішення запускається алгоритм пошуку, який повертає покращений розв’язок за допомогою `Solver.search`.